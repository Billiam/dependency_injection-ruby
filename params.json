{"name":"Dependency injection for Ruby","tagline":"","body":"# Dependency Injection for Ruby\r\n[![Build Status](https://travis-ci.org/kdisneur/dependency_injection-ruby.png?branch=master)](https://travis-ci.org/kdisneur/dependency_injection-ruby) [![Coverage Status](https://coveralls.io/repos/kdisneur/dependency_injection-ruby/badge.png?branch=master)](https://coveralls.io/r/kdisneur/dependency_injection-ruby?branch=master) [![Code Climate](https://codeclimate.com/github/kdisneur/dependency_injection-ruby.png)](https://codeclimate.com/github/kdisneur/dependency_injection-ruby)\r\n\r\n## Foreword\r\n\r\nThis gem is heavily inspired from The Symfony Framework [Container Service](http://symfony.com/doc/current/book/service_container.html). Here's the description they give to explain the concept:\r\n\r\n> It helps you instantiate, organize and retrieve the many objects of your application. This object, called a service container, will allow you to standardize and centralize the way objects are constructed in your application. The container makes your life easier, is super fast, and emphasizes an architecture that promotes reusable and decoupled code.\r\n\r\nYou can learn more about everything this gem does by looking at the [examples](https://github.com/kdisneur/dependency_injection-ruby/tree/master/examples) directory. See [Usage](#usage) for a detailed explanation.\r\n\r\n## Description\r\n\r\n### Installation\r\n\r\nJust add the gem to your Gemfile:\r\n\r\n```ruby\r\ngem 'dependency_injection'\r\n```\r\n\r\nOr simply install it using rubygems:\r\n\r\n```shell\r\ngem install dependency_injection\r\n```\r\n\r\n### Example\r\n\r\n#### Without using Dependency Injection\r\n\r\nIn this example, we'll consider a simple application that needs to send emails for a newsletter.\r\n\r\nWe have the two following classes:\r\n\r\n```ruby\r\n# mailer.rb\r\nclass Mailer\r\n  attr_accessor :transporter\r\n\r\n  def initialize\r\n    puts 'mailer initialized'\r\n  end\r\n\r\n  def send_mail(message, recipient)\r\n    puts \"mail sent via #{self.transporter}: #{message}\"\r\n  end\r\nend\r\n```\r\n\r\n```ruby\r\n# newsletter_manager.rb\r\nclass NewsletterManager\r\n  def initialize(mailer)\r\n    @mailer = mailer\r\n  end\r\n\r\n  def send_newsletter(message, recipients)\r\n    puts 'newsletter #{message} send to #{recipients}'\r\n    recipients.each { |recipient| @mailer.send_mail(message, recipient) }\r\n  end\r\nend\r\n```\r\n\r\nA `Mailer` class that handles email sending, through a given transporter, for a recipient.\r\n\r\nA `NewsletterManager` class that sends a newsletter (message) to a list of recipients.\r\n\r\nWithout __DependencyInjection__, we would need to do the following to achieve our goal:\r\n\r\n```ruby\r\n# send_newsletter.rb\r\nmailer = Mailer.new\r\nmailer.transporter = :smtp\r\n\r\nrecipients = %w(john@doe.com david@heinemeier-hansson.com)\r\nmessage    = 'I love dependency injection and think this is the future!'\r\n\r\nnewsletter_manager = NewsletterManager.new(mailer)\r\nnewsletter_manager.send_newsletter(message, recipients)\r\n```\r\n\r\nYou have a working application but this code is thightly coupled and might be, in a real life, hard to refactor.\r\n\r\nAnother big drawback is that you have to instantiate as many objects as you have emails and newsletters to send.\r\n\r\n#### Now with Dependency Injection\r\n\r\nOur two classes stay untouched, the only thing you have to do is to add a configuration file.\r\n\r\n```yaml\r\n# services.yml\r\nparameters:\r\n  mailer.transporter: 'smtp'\r\nservices:\r\n  mailer:\r\n    class: 'Mailer'\r\n    calls:\r\n      - ['transporter=', '%mailer.transporter%']\r\n  newsletter_manager:\r\n    class: 'NewsletterManager'\r\n    arguments:\r\n      - '@mailer'\r\n```\r\n\r\nWe now need to require __DependencyInjection__ and declare our __Container__.\r\n\r\nPlease note that the following code only needs to be declared once as long as the `container` value is accessible throughout your whole application.\r\n\r\n```ruby\r\n# initialize.rb\r\nrequire 'dependency_injection/container'\r\nrequire 'dependency_injection/loaders/yaml'\r\n\r\ncontainer = DependencyInjection::Container.new\r\nloader    = DependencyInjection::Loaders::Yaml.new(container)\r\nloader.load(File.join(File.dirname(File.expand_path(__FILE__)), 'services.yml'))\r\n```\r\n\r\nWe can now do the same as the previous example with the following.\r\n\r\n```ruby\r\n# send_newsletter.rb\r\nrecipients = %w(john@doe.com david@heinemeier-hansson.com)\r\nmessage    = 'I love dependency injection and think this is the future!'\r\n\r\ncontainer.get('newsletter_manager').send_newsletter(message, recipients)\r\n```\r\n\r\nNow your code is no longer tightly coupled and can be a lot more easily refactored. Moreover, the `Mailer` and `NewsletterManager` classes are only instantiated once during your application's lifecycle.\r\n\r\n### Usage\r\n\r\nBefore diving into the details of __DependencyInjection__, here are some keywords that you need to be acquainted with:\r\n\r\n* __Container__ object must be declared to be used by your application during it's whole lifecycle. The Container job is to register and retrieve Services.\r\n\r\n* __Service__ is a Plain Old Ruby Object (Poro o/) that contains your own logic. The __DependencyInjection__ gem doesn't need to know anything about it and won't force your to add/inherit any specific method.\r\n\r\n* __Configurator__ is a standard Ruby Class that shares a callable to be used by different objects (like Services) to configure them after their instantiation.\r\n\r\n#### Configuration\r\n\r\n__DependencyInjection__ needs to be configured, using a yaml file, in order to map your services with your existing classes and their dependencies. There's also some other options that we'll list below.\r\n\r\nHere's a configuration file example using almost everything __DependencyInjection__ has to offer:\r\n\r\n```yaml\r\nparameters:\r\n  mailer.transport: smtp\r\nservices:\r\n  mailer:\r\n    class: Mailer\r\n    calls:\r\n      - ['transport=', '%mailer.transport%']\r\n    lazy: true\r\n  newsletter:\r\n    class: NewsletterManager\r\n    arguments:\r\n      - '@mailer'\r\n```\r\n\r\nAnd here's some more details about each keyword:\r\n\r\n* `parameters`: Based on a basic key/value scheme. This can later be used throughout your services by calling `%parameter_name%`.\r\n\r\n* `services`: The services name must be used as the first indentation tier.\r\n\r\n* `class`: A string containing the class name of your service.\r\n\r\n* `arguments`: An array containing the parameters used by your class `intialize` method.\r\n\r\n* `calls`: An array containing an array of each instance method and its parameters. Note that you only need to define the methods during your class instantiation.\r\n\r\n* `lazy`: Returns a Proxy Object if true. The _real_ object will only be instantiated at the first method call.\r\n\r\n* `alias`: A string containing the target service name.\r\n\r\n* `scope`: A string containing one of two possibles values to handle the service initialization scope:\r\n  * `container`: a service is initialized only once throughout the container life (default)\r\n  * `prototype`: a new service is initialized each time you call the container\r\n\r\n  Note that the usage of a `prototype` service inside a `container` service raises a `ScopeWideningInjectionError`\r\n\r\n__Please note:__\r\n* You can reference a variable in the configuration with the following syntax: `%variable%`.\r\n* You can reference declared services by prefixing it with an `@` sign.\r\n* If you declare a service as an alias, the target service configuration will be used. Your own service configuration will be ignored.\r\n\r\n### Tests\r\n\r\n__DependencyInjection__ is covered by tests at 100%, see [coveralls.io](https://coveralls.io/r/kdisneur/dependency_injection-ruby) service.\r\n\r\nIf you want to launch the tests by yourself:\r\n* Clone this repository by running `git clone git@github.com:kdisneur/dependency_injection-ruby`\r\n* Run `bundle install`\r\n* Run `rake test`\r\n\r\n## Contribute\r\n\r\nThis is Github folks!\r\n\r\nIf you find a *bug*, open an [Issue](https://github.com/kdisneur/dependency_injection-ruby/issues).\r\n\r\nIt's OK to open an issue to ask us what we think about a change you'd like to make, so you don't work for nothing :)\r\n\r\nIf you want to add/change/hack/fix/improve/whatever something, make a [Pull Request](https://github.com/kdisneur/dependency_injection-ruby/pulls):\r\n\r\n* Fork this repository\r\n* Create a feature branch on your fork, we just love [git-flow](http://nvie.com/posts/a-successful-git-branching-model/)\r\n* Do your stuff and pay attention to the following:\r\n * Your code should be documented using [Tomdoc](http://tomdoc.org)\r\n * You should follow [Github's Ruby Styleguide](https://github.com/styleguide/ruby)\r\n * If needed, squash your commits to group them logically\r\n * Update the CHANGELOG accordingly\r\n* Make a Pull Request, we will *always* respond, and try to do it fast.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}